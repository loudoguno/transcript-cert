"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
class Merkle {
    constructor(options) {
        this.$options = Object.assign({ hasher: (v) => v }, options);
    }
    notarize(data) {
        return __awaiter(this, void 0, void 0, function* () {
            const values = [...data];
            const nodes = [yield this.$options.hasher('')];
            for (let i = values.length - 1; i >= 0; i--) {
                const right = nodes[0];
                const value = values[i];
                nodes.unshift(yield this.$options.hasher(value));
                const left = nodes[0];
                nodes.unshift(yield this.$options.hasher(`${left}${right}`));
            }
            return {
                values: values.map((value, index) => ({ index, value })),
                nodes: nodes.map((hash, index) => ({ index, hash })),
            };
        });
    }
    disclose(recipe, expose) {
        return __awaiter(this, void 0, void 0, function* () {
            const size = Math.max(...expose.map((i) => i + 1), 0);
            const values = [];
            const nodes = [
                recipe.nodes.find((n) => n.index === size * 2),
            ];
            for (let i = size - 1; i >= 0; i--) {
                if (expose.indexOf(i) !== -1) {
                    values.unshift(recipe.values.find((n) => n.index === i));
                }
                else {
                    nodes.unshift(recipe.nodes.find((n) => n.index === i * 2 + 1));
                }
            }
            return { values, nodes };
        });
    }
    imprint(evidence) {
        return __awaiter(this, void 0, void 0, function* () {
            const nodes = [
                ...yield Promise.all(evidence.values.map((v) => __awaiter(this, void 0, void 0, function* () {
                    return ({
                        index: v.index * 2 + 1,
                        hash: yield this.$options.hasher(v.value),
                        value: v.value,
                    });
                }))),
                ...evidence.nodes,
            ];
            const size = Math.max(...nodes.map((n) => n.index + 1), 0);
            for (let i = size - 1; i >= 0; i -= 2) {
                const right = nodes.find((n) => n.index === i);
                const left = nodes.find((n) => n.index === i - 1);
                if (right && left) {
                    nodes.unshift({
                        index: i - 2,
                        hash: yield this.$options.hasher(`${left.hash}${right.hash}`),
                    });
                }
            }
            const root = nodes.find((n) => n.index === 0);
            return root ? root.hash : null;
        });
    }
}
exports.Merkle = Merkle;
//# sourceMappingURL=merkle.js.map