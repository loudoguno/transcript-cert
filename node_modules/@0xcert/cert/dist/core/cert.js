"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const merkle_1 = require("@0xcert/merkle");
const utils_1 = require("@0xcert/utils");
const data_1 = require("../utils/data");
class Cert {
    static getInstance(config) {
        return new Cert(config);
    }
    constructor(config) {
        this.schema = config.schema;
        this.merkle = new merkle_1.Merkle(Object.assign({ hasher: (v) => utils_1.sha(256, data_1.toString(v)) }, config));
    }
    notarize(data) {
        return __awaiter(this, void 0, void 0, function* () {
            const schemaProps = this.buildSchemaProps(data);
            const compoundProps = yield this.buildCompoundProps(schemaProps);
            const schemaProofs = yield this.buildProofs(compoundProps);
            return schemaProofs.map((proof) => ({
                path: proof.path,
                nodes: proof.nodes,
                values: proof.values,
            }));
        });
    }
    disclose(data, paths) {
        return __awaiter(this, void 0, void 0, function* () {
            const schemaProps = this.buildSchemaProps(data);
            const compoundProps = yield this.buildCompoundProps(schemaProps);
            const schemaProofs = yield this.buildProofs(compoundProps, paths);
            return schemaProofs.map((proof) => ({
                path: proof.path,
                nodes: proof.nodes,
                values: proof.values,
            }));
        });
    }
    calculate(data, proofs) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (this.checkDataInclusion(data, proofs)) {
                    return this.imprintProofs(proofs);
                }
                else {
                    return null;
                }
            }
            catch (e) {
                return null;
            }
        });
    }
    imprint(data) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.notarize(data)
                .then((n) => n[0].nodes[0].hash);
        });
    }
    buildSchemaProps(data, schema = this.schema, prepend = []) {
        if (schema.type === 'array') {
            return (data || [])
                .map((v, i) => {
                return this.buildSchemaProps(v, schema.items, [...prepend, i]);
            })
                .reduce((a, b) => a.concat(b), []);
        }
        else if (schema.type === 'object') {
            return Object.keys(schema.properties)
                .sort()
                .map((key) => {
                const prop = this.buildSchemaProps((data || {})[key], schema.properties[key], [...prepend, key]);
                return ['object', 'array'].indexOf(schema.properties[key].type) === -1 ? [prop] : prop;
            })
                .reduce((a, b) => a.concat(b), []);
        }
        else {
            return {
                path: prepend,
                value: data,
                key: prepend.join('.'),
                group: prepend.slice(0, -1).join('.'),
            };
        }
    }
    buildCompoundProps(props) {
        return __awaiter(this, void 0, void 0, function* () {
            props = [...props];
            const groupsByName = this.buildPropGroups(props);
            const groups = Object.keys(groupsByName).sort((a, b) => a > b ? -1 : 1)
                .filter((g) => g !== '');
            for (const group of groups) {
                const path = groupsByName[group];
                const values = [...props.filter((i) => i.group === group)]
                    .sort((a, b) => a.key > b.key ? 1 : -1)
                    .map((i) => i.value);
                const proofs = yield this.merkle.notarize(values);
                props.push({
                    path,
                    value: proofs.nodes[0].hash,
                    key: path.join('.'),
                    group: path.slice(0, -1).join('.'),
                });
            }
            return props.sort((a, b) => a.key > b.key ? 1 : -1);
        });
    }
    buildProofs(props, paths = null) {
        return __awaiter(this, void 0, void 0, function* () {
            const keys = paths ? data_1.stepPaths(paths).map((p) => p.join('.')) : null;
            const groups = {};
            props.forEach((p) => groups[p.group] = p.path.slice(0, -1));
            return Promise.all(Object.keys(groups).map((group) => __awaiter(this, void 0, void 0, function* () {
                const values = props
                    .filter((p) => p.group === group)
                    .map((p) => p.value);
                let evidence = yield this.merkle.notarize(values);
                if (keys) {
                    const expose = props
                        .filter((p) => p.group === group)
                        .map((p, i) => keys.indexOf(p.key) === -1 ? -1 : i)
                        .filter((i) => i !== -1);
                    evidence = yield this.merkle.disclose(evidence, expose);
                }
                if (!keys || keys.indexOf(groups[group].join('.')) !== -1) {
                    return {
                        path: groups[group],
                        values: evidence.values,
                        nodes: evidence.nodes,
                        key: groups[group].join('.'),
                        group: groups[group].slice(0, -1).join('.'),
                    };
                }
            }))).then((r) => {
                return r.filter((v) => !!v);
            });
        });
    }
    checkDataInclusion(data, proofs) {
        const schemaProps = this.buildSchemaProps(data);
        proofs = data_1.cloneObject(proofs).map((p) => (Object.assign({ key: p.path.join('.'), group: p.path.slice(0, -1).join('.') }, p)));
        for (const prop of schemaProps) {
            const dataValue = data_1.readPath(prop.path, data);
            if (typeof dataValue === 'undefined') {
                continue;
            }
            const proofGroup = prop.path.slice(0, -1).join('.');
            const proof = proofs.find((p) => p['key'] === proofGroup);
            if (!proof) {
                return false;
            }
            const dataIndex = this.getPathIndexes(prop.path).pop();
            const proofValue = proof.values.find((v) => v.index === dataIndex);
            if (proofValue.value !== dataValue) {
                return false;
            }
        }
        return true;
    }
    imprintProofs(proofs) {
        return __awaiter(this, void 0, void 0, function* () {
            if (proofs.length === 0) {
                return this.getEmptyImprint();
            }
            proofs = data_1.cloneObject(proofs).map((prop) => (Object.assign({ key: prop.path.join('.'), group: prop.path.slice(0, -1).join('.') }, prop))).sort((a, b) => a.path.length > b.path.length ? -1 : 1);
            for (const proof of proofs) {
                const imprint = yield this.merkle.imprint(proof).catch(() => '');
                proof.nodes.unshift({
                    index: 0,
                    hash: imprint,
                });
                const groupKey = proof.path.slice(0, -1).join('.');
                const groupIndex = this.getPathIndexes(proof.path).slice(-1).pop();
                const groupProof = proofs.find((p) => p['key'] === groupKey);
                if (groupProof) {
                    groupProof.values.unshift({
                        index: groupIndex,
                        value: imprint,
                    });
                }
            }
            const root = proofs.find((f) => f['key'] === '');
            if (root) {
                return root.nodes.find((n) => n.index === 0).hash;
            }
            else {
                return this.getEmptyImprint();
            }
        });
    }
    getPathIndexes(keys) {
        const indexes = [];
        let schema = this.schema;
        for (const key of keys) {
            if (schema.type === 'array') {
                indexes.push(key);
                schema = schema.items;
            }
            else if (schema.type === 'object') {
                indexes.push(Object.keys(schema.properties).sort().indexOf(key));
                schema = schema.properties[key];
            }
            else {
                indexes.push(undefined);
            }
        }
        return indexes;
    }
    getEmptyImprint() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.merkle.notarize([]).then((e) => e.nodes[0].hash);
        });
    }
    buildPropGroups(props) {
        const groups = {};
        props.map((p) => {
            const path = [];
            return p.path.map((v) => {
                path.push(v);
                return [...path];
            });
        }).reduce((a, b) => a.concat(b), []).forEach((p) => {
            return groups[p.slice(0, -1).join('.')] = p.slice(0, -1);
        });
        return groups;
    }
}
exports.Cert = Cert;
//# sourceMappingURL=cert.js.map